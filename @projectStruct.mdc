# Next.js API 学习项目 - 项目结构规范

## 项目概述

这是一个用于学习 Next.js 15 API、Tailwind CSS 和 shadcn/ui 的项目。

## 技术栈

- **框架**: Next.js 15 (App Router)
- **样式**: Tailwind CSS 4
- **UI 组件**: shadcn/ui
- **包管理器**: pnpm
- **语言**: TypeScript

## 项目结构

```
src/
├── app/                 # Next.js App Router 页面
│   ├── layout.tsx      # 根布局
│   ├── page.tsx        # 首页
│   ├── globals.css     # 全局样式
│   ├── ssr/            # SSR 示例页面
│   ├── ssg/            # SSG 示例页面
│   ├── isr/            # ISR 示例页面
│   └── client-server-test/  # 客户端服务端组件测试页面
├── components/          # shadcn/ui 基础组件
│   ├── ui/             # shadcn/ui 组件库
│   └── ThemeToggle.tsx # 全局主题切换组件
├── features/           # 功能模块组件（核心组织原则）
│   ├── ssr/           # SSR 路由相关组件
│   ├── ssg/           # SSG 路由相关组件
│   └── isr/           # ISR 路由相关组件
└── lib/                # 工具函数
    └── utils.ts        # 通用工具函数
```

## 组件组织规范

### 1. Features 组件组织核心规则

**重要原则：所有页面特定的组件都应该写到 `features` 对应的文件夹下。**

#### 1.1 按路由分组组织

```
features/
├── ssr/                    # /ssr 路由相关的所有组件
│   ├── index.ts           # 统一导出文件
│   ├── RefreshButton.tsx  # SSR 页面专用组件
│   ├── Separator.tsx      # SSR 页面分隔符组件
│   ├── ServerComponent.tsx           # 服务端组件示例
│   ├── ClientWithServerComponent.tsx # 客户端组件示例
│   ├── BrokenClientComponent.tsx     # 错误示例组件
│   ├── CorrectSolution.tsx          # 正确解决方案组件
│   └── ClientCounter.tsx            # 客户端计数器组件
├── ssg/                    # /ssg 路由相关的所有组件
│   ├── index.ts
│   └── [SGG相关组件].tsx
├── isr/                    # /isr 路由相关的所有组件
│   ├── index.ts
│   ├── ISRInfoCard.tsx
│   ├── NewsCard.tsx
│   ├── StatsCard.tsx
│   └── WeatherCard.tsx
└── [route-name]/          # 其他路由对应的组件
    ├── index.ts
    └── [组件文件].tsx
```

#### 1.2 组件分类规则

**📁 Features 文件夹下的组件类型：**

1. **页面特定组件** - 只在特定路由页面使用的组件
2. **功能组件** - 实现特定功能逻辑的组件（如数据展示、用户交互）
3. **布局组件** - 页面内的布局相关组件
4. **业务逻辑组件** - 包含特定业务逻辑的组件

**📁 Components/ui 文件夹下的组件类型：**

1. **基础 UI 组件** - shadcn/ui 组件库
2. **通用组件** - 跨多个页面使用的基础组件

**📁 Components 根目录下的组件类型：**

1. **全局组件** - 整个应用级别的组件（如 ThemeToggle）
2. **布局组件** - 全局布局相关组件

### 2. 文件组织结构

#### 2.1 每个 features 子文件夹必须包含

```typescript
// features/[route-name]/index.ts
/**
 * [Route Name] 功能组件集合
 * 包含 [route-name] 页面相关的所有组件
 */

export { ComponentA } from './ComponentA';
export { ComponentB } from './ComponentB';
// ... 其他组件导出
```

#### 2.2 组件文件命名规范

- **组件文件**: 使用 PascalCase: `RefreshButton.tsx`、`ServerComponent.tsx`
- **功能文件夹**: 使用路由名称: `ssr/`、`ssg/`、`isr/`
- **导出文件**: 固定使用 `index.ts`

### 3. 导入使用规范

#### 3.1 正确的导入方式

```typescript
// ✅ 从对应路由的 features 导入页面特定组件
import { RefreshButton, Separator, ServerComponent } from '@/features/ssr';

// ✅ 从基础 UI 组件库导入通用组件
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

// ✅ 从全局组件导入
import { ThemeToggle } from '@/components/ThemeToggle';
```

#### 3.2 错误的组织方式

```typescript
// ❌ 不要把页面特定组件放到全局 components
import { RefreshButton } from '@/components/RefreshButton'; // 错误！

// ❌ 不要跨路由导入其他路由的特定组件
import { SSRSpecificComponent } from '@/features/ssr'; // 在 ISR 页面中使用
```

### 4. 组件创建指导原则

#### 4.1 创建新组件时的决策流程

1. **问：这个组件是否只在特定路由页面使用？**
   - 是 → 放入对应的 `features/[route-name]/` 文件夹
   - 否 → 继续下一步

2. **问：这个组件是否是基础 UI 组件？**
   - 是 → 考虑使用 shadcn/ui 或放入 `components/ui/`
   - 否 → 继续下一步

3. **问：这个组件是否是全局级别的？**
   - 是 → 放入 `components/` 根目录
   - 否 → 重新评估组件用途

#### 4.2 组件类型指导

```typescript
// 📁 features/ssr/ServerComponent.tsx
/**
 * 服务端组件示例 - SSR 页面专用
 * 只在 SSR 相关页面中使用
 */
export async function ServerComponent() {
  // 服务端逻辑
}

// 📁 features/ssr/ClientCounter.tsx
/**
 * 客户端计数器组件 - SSR 页面专用
 * 包含客户端交互逻辑，只在 SSR 相关功能中使用
 */
('use client');
export function ClientCounter() {
  // 客户端交互逻辑
}

// 📁 components/ui/button.tsx
/**
 * 基础按钮组件 - 全局可用
 * shadcn/ui 组件，可在任意页面使用
 */
export function Button() {
  // 基础 UI 逻辑
}

// 📁 components/ThemeToggle.tsx
/**
 * 主题切换组件 - 全局级别
 * 整个应用级别的功能组件
 */
('use client');
export function ThemeToggle() {
  // 全局主题逻辑
}
```

### 5. 开发工作流程

#### 5.1 新增路由页面时

1. 在 `app/` 下创建路由页面
2. 在 `features/` 下创建对应的文件夹
3. 创建 `index.ts` 导出文件
4. 在对应 features 文件夹下开发页面特定组件

#### 5.2 开发页面组件时

```typescript
// Step 1: 在 features/[route-name]/ 下创建组件
// features/ssr/NewComponent.tsx
export function NewComponent() {
  return <div>新组件</div>;
}

// Step 2: 在 index.ts 中添加导出
// features/ssr/index.ts
export { NewComponent } from './NewComponent';

// Step 3: 在页面中使用
// app/ssr/page.tsx
import { NewComponent } from '@/features/ssr';
```

### 6. 组件边界和职责

#### 6.1 服务端组件 vs 客户端组件

```typescript
// ✅ 服务端组件：数据获取、异步操作
export async function ServerComponent() {
  const data = await fetchData();
  return <div>{data}</div>;
}

// ✅ 客户端组件：用户交互、状态管理
'use client';
export function ClientComponent() {
  const [state, setState] = useState();
  return <button onClick={() => setState()}>交互</button>;
}

// ❌ 不要在客户端组件中直接渲染服务端组件
'use client';
export function WrongComponent() {
  return <ServerComponent />; // 错误！
}

// ✅ 正确的组合方式：在服务端组件中组合
export function CorrectComposition() {
  return (
    <div>
      <ServerComponent />
      <ClientComponent />
    </div>
  );
}
```

### 7. 最佳实践总结

1. **严格按路由组织组件** - 每个路由的组件都放在对应的 features 文件夹
2. **明确组件边界** - 区分页面特定组件和全局组件
3. **统一导出管理** - 使用 index.ts 统一管理组件导出
4. **清晰的组件职责** - 每个组件有明确的功能和使用场景
5. **遵循 Next.js 渲染边界** - 正确处理服务端组件和客户端组件的关系

这个组织结构确保了：

- 📁 代码组织清晰，便于维护
- 🔍 组件易于查找和定位
- 🔄 支持组件复用而不造成混乱
- 📚 新团队成员容易理解项目结构
- 🚀 符合 Next.js 15 的最佳实践
